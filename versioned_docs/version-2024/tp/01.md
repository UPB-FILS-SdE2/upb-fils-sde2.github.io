---
sidebar_position: 2
description: Une introduction au langage Rust.
---

# TP 01 - Rust pour les dÃ©butants

## Assignment
:::info
Vous devez **accepter** la tÃ¢che d'ici et travailler avec ce **dÃ©pÃ´t**: Lab0
:::
## Resources
 1. The Rust Programming Language, Chapitre [1](https://jimskapt.github.io/rust-book-fr/ch01-00-getting-started.html), [2](https://jimskapt.github.io/rust-book-fr/ch02-00-guessing-game-tutorial.html), [3](https://jimskapt.github.io/rust-book-fr/ch03-00-common-programming-concepts.html) et [5](https://jimskapt.github.io/rust-book-fr/ch05-00-structs.html) ([version anglaise](https://doc.rust-lang.org/book/#the-rust-programming-language))
 2. [Tour of Rust](https://tourofrust.com/00_fr.html) tutoriel Ã©tape par Ã©tape

## Concepts basiques de langages de programmation pour Rust
### BibliothÃ¨que standard

La bibliothÃ¨que standard est divisÃ©e en trois niveauxÂ :

| Niveau | Description | Besoin |
|-------|:------------|:------|
| [`core`](https://doc.rust-lang.org/core/index.html) | Fournit les Ã©lÃ©ments de langage requis dont Rust a besoin pour la compilation, comme les traits `Display` et `Debug`. Les donnÃ©es ne peuvent Ãªtre que des Ã©lÃ©ments globaux (stockÃ©s dans *.data*) ou sur la *pile*. | Hardware |
| [`alloc`](https://doc.rust-lang.org/alloc/index.html) | Fournit tout, depuis le niveau `core` ainsi que les structures de donnÃ©es allouÃ©es *tas* comme `Box` et `Vec`. Le dÃ©veloppeur doit fournir un allocateur de mÃ©moire, comme [embedded_alloc](https://docs.rs/embedded-alloc/latest/embedded_alloc/). | Memory Allocator |
| [`std`](https://doc.rust-lang.org/std/index.html) | Fournit tout, depuis le niveau `alloc`, ainsi que de nombreuses fonctionnalitÃ©s qui dÃ©pendent de la plate-forme, y compris les fils d'exÃ©cution et les E/S. Il s'agit du niveau par dÃ©faut pour les applications Windows, Linux, macOS et systÃ¨mes d'exploitation similaires. | Operating System |


Par dÃ©faut, Rust a un ensemble d'Ã©lÃ©ments dÃ©finis dans la bibliothÃ¨que standard qu'il introduit dans le cadre d'application de chaque programme. Cet ensemble s'appelle le prÃ©lude, et vous pouvez voir tout ce qu'il contient dans la documentation standard de la [bibliothÃ¨que](https://doc.rust-lang.org/std/prelude/index.html).

Si un type que vous voulez utiliser n'est pas dans le prÃ©lude, vous devez mettre ce type dans la portÃ©e **explicitement** avec une instruction use. L'utilisation de la bibliothÃ¨que std :: io vous offre un certain nombre de fonctionnalitÃ©s utiles, notamment la possibilitÃ© d'accepter les entrÃ©es de l'utilisateur.
```rust
use std::io;
```

### La fonction `main`
La fonction `main` est le point d'entrÃ©e de notre programme.

```rust
fn main() {
    println!("Hello, world!");
}
```

On utilise `println!()` pour imprimer des messages sur l'Ã©cran.

Pour insÃ©rer une marque substitutive dans la macro `println!`, utilisez une *paire d'accolades* `{}`. Nous fournissons le nom ou l'expression de la variable pour **remplacer** la marque substitutive fournie en dehors de la chaÃ®ne.

```rust
fn main() {

    let name = "Mary";
    let age = 26;
    let color = "blue";
 
    println!("Hello, {}. You are {} years old", name, age);
    println!("What is your favourite color? Is it {color}?");
}
```

### Variables et mutabilitÃ©
On utilise le mot-clÃ© `let` pour crÃ©er une variable.

```rust
let a = 5;
```

Par dÃ©faut, en Rust, les variables sont **immuables**, Ã§a veut dire qu'une fois une valeur affectuÃ©e Ã  un nom, vous **ne pouvez pas** modifier cette valeur.

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
Dans ce cas, on va obtenir une erreur de compilation parce quâ€™on essaye de modifier la valeur de `x` de 5 Ã  6, mais `x` est immuable, donc on ne peut pas faire cette modification.

Bien que les variables soient immuables par dÃ©faut, vous pouvez les rendre **modifiables** en ajoutant `mut` devant le nom de la variable. L'ajout de `mut` transmet Ã©galement l'intention aux futurs lecteurs du code en indiquant que d'autres parties de code modifieront la valeur de cette variable.
```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
Maintenant, la valeur de `x` peut devenir `6`.

### Constantes

Comme les variables immuables, les constantes sont des valeurs qui sont liÃ©es Ã  un nom et **ne sont pas autorisÃ©es Ã  changer**, mais il existe quelques diffÃ©rences entre les constantes et les variables.

Les variables `const` sont des variables dont la valeur doit Ãªtre connue Ã  la compilation Ã  la diffÃ©rence des variables `let` dont la valeur est dÃ©terminÃ©e au moment de l'exÃ©cution du programme.

Tout d'abord, vous n'Ãªtes pas autorisÃ©s Ã  utiliser `mut` avec des constantes. Les constantes ne sont pas seulement immuables par dÃ©faut, elles sont toujours immuables. Vous dÃ©clarez des constantes en utilisant le mot clÃ© *const* au lieu du mot clÃ© *let*.

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```
:::note
Pour comprendre mieux, lire le [chapitre 3](https://jimskapt.github.io/rust-book-fr/ch03-00-common-programming-concepts.html) qui se trouve dans la documentation au dÃ©but du TP!
:::
### Types des donnÃ©es
#### Types scalaire
Un type scalaire reprÃ©sente une valeur unique. Rust a quatre types scalaires principaux : entiers, nombres Ã  virgule flottante, boolÃ©ens et caractÃ¨res.

**Integer** â†’ Chaque variante peut Ãªtre signÃ©e ou non signÃ©e et a une taille explicite.

```rust
let x: i8 = -2;
let y: u16 = 25;
```

| Longueur              | SignÃ© | Non signÃ© | Ã‰quivalent en Java |
| :----------------: | :------: | :----: | :----: |
| 8-bit |   `i8`   | `u8` | `byte`/ `Byte`[^java_unsigned] |
| 16-bit |   `i16`   | `u16` | `short` / `Short`[^java_unsigned] |
| 32-bit |   `i32`   | `u32` | `int` / `Integer`[^java_unsigned] |
| 64-bit |   `i64`   | `u64` | `long` / `Long`[^java_unsigned] |
| 128-bit |   `i128`   | `u128` | N/A |
| arch |   `isize`   | `usize` | N/A |

**Virgule flottante** â†’ Les types Ã  virgule flottante de Rust sont f32 et f64, qui ont respectivement une taille de 32 bits et 64 bits. Le type par dÃ©faut est **f64** car sur les processeurs modernes, les calculs utilisant f64 ont Ã  peu prÃ¨s la mÃªme vitesse que f32, mais sont plus prÃ©cis. Tous les types Ã  virgule flottante sont **signÃ©s**.
| Longueur              | Virgule flottante | Ã‰quivalent en Java |
| :----------------: | :------: | :----: | 
| 32-bit | `f32` | `float` |
| 64-bit | `f64` | `double` |
```rust
fn main() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32
}
```

**Boolean** â†’ Les boolÃ©ens ont une taille d'un octet. Le type boolÃ©en dans Rust est spÃ©cifiÃ© Ã  l'aide de *bool*.

```rust
let t = true;
let f: bool = false; // with explicit type annotation
```

**Caractere** â†’ Le type char de Rust est le type alphabÃ©tique le plus primitif du langage.

```rust
let c = 'z';
let z: char = 'â„¤'; // with explicit type annotation
let heart_eyed_cat = 'ðŸ˜»';
```

#### Types composÃ©s
**Tuple** â†’ Un tuple est une maniÃ¨re gÃ©nÃ©rale de regrouper un certain nombre de valeurs avec une variÃ©tÃ© de types en un seul type composÃ©. Les tuples ont une longueur **fixe** : une fois dÃ©clarÃ©s, leur taille ne peut pas augmenter ou diminuer.

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
```

**Array** â†’ Contrairement Ã  un tuple, chaque Ã©lÃ©ment d'un tableau doit avoir le **mÃªme type**. Contrairement aux tableaux de certains autres langages, les tableaux de Rust ont une longueur **fixe**.

```rust
let a = [1, 2, 3, 4, 5];
```
:::note
Pour comprendre mieux, lire le [chapitre 3](https://jimskapt.github.io/rust-book-fr/ch03-00-common-programming-concepts.html) qui se trouve dans la documentation au dÃ©but du TP!
:::

### Fonctions

Nous dÃ©finissons une fonction dans Rust en tapant *fn* suivi d'un nom de fonction et d'un ensemble de parenthÃ¨ses. Les accolades indiquent au compilateur oÃ¹ commence et se termine le corps de la fonction.

```rust
fn main() {
    println!("Hello, world!");
 
    another_function();
}
 
fn another_function() {
    println!("Another function.");
}

```

#### ParamÃ¨tres

Nous pouvons dÃ©finir des fonctions avec des paramÃ¨tres, qui sont des variables spÃ©ciales qui font partie de la signature d'une fonction. Lorsqu'une fonction a des paramÃ¨tres, vous pouvez lui fournir des **valeurs concrÃ¨tes** pour ces paramÃ¨tres.
```rust
fn main() {
    another_function(5);
}
 
fn another_function(x: i32) {
    println!("The value of x is: {x}");
}

```
:::note
Dans les signatures de fonctions, vous devez dÃ©clarer le **type** de chaque paramÃ¨tre!
:::
#### DÃ©clarations vs. expressions

Les corps de fonction sont constituÃ©s d'une sÃ©rie d'instructions se terminant Ã©ventuellement par une expression.

Les **dÃ©clarations** sont des instructions qui effectuent une action et ne renvoient pas de valeur.

Les **expressions** Ã©valuent une valeur rÃ©sultante.

:::info
Pour comprendre mieux, lire le [chapitre 3](https://jimskapt.github.io/rust-book-fr/ch03-00-common-programming-concepts.html) qui se trouve dans la documentation au dÃ©but du TP! 
:::

#### Fonctions avec valeurs de retour

Les fonctions peuvent renvoyer des valeurs au code qui les appelle. Nous ne nommons pas les valeurs de retour, mais nous devons dÃ©clarer leur type aprÃ¨s **une flÃ¨che (->)**. En Rust, la valeur de retour de la fonction est synonyme de la valeur de **l'expression finale** dans le bloc du corps d'une fonction. Vous pouvez revenir plus tÃ´t Ã  partir d'une fonction en utilisant le mot-clÃ© *return* et en spÃ©cifiant une valeur, mais la plupart des fonctions renvoient implicitement la derniÃ¨re expression.

```rust
fn five() -> i32 {
    5
}
 
fn main() {
    let x = five();
    println!("The value of x is: {x}");// "The value of x is: 5"
}

```
:::note
Pour comprendre mieux, lire le [chapitre 3](https://jimskapt.github.io/rust-book-fr/ch03-00-common-programming-concepts.html) qui se trouve dans la documentation au dÃ©but du TP!
:::
### Flux de contrÃ´le

#### if-else

Toutes les expressions `if` commencent par le mot-clÃ© `if`, suivies d'une condition. Facultativement, nous pouvons Ã©galement inclure une expression `else`.

```rust
fn main() {
    let number = 3;
 
    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```

Vous pouvez utiliser plusieurs conditions en combinant `if` et `else` dans une expression `else if`:

```rust
fn main() {
    let number = 6;
 
    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```
Parce que `if` est une expression, nous pouvons l'utiliser sur **le cÃ´tÃ© droit** d'une instruction `let` pour affecter le rÃ©sultat Ã  une variable.

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };
 
    println!("The value of number is: {number}");//"The value of the number is 5"
}
```

#### Loop

Le mot-clÃ© `loop` indique Ã  Rust d'exÃ©cuter un bloc de code encore et encore pour toujours ou jusqu'Ã  ce que vous lui disiez **explicitement** de s'arrÃªter.

```rust
fn main() {
    loop {
        println!("again!");
    }
}
```
L'une des utilisations d'une boucle est de *rÃ©essayer* une opÃ©ration dont vous savez qu'elle pourrait Ã©chouer, comme vÃ©rifier si un thread a terminÃ© son travail. Vous devrez peut-Ãªtre Ã©galement transmettre le rÃ©sultat de cette opÃ©ration hors de la boucle au reste de votre code. Pour ce faire, vous pouvez ajouter la valeur que vous souhaitez renvoyer aprÃ¨s l'expression break que vous utilisez pour arrÃªter la boucle ; cette valeur sera renvoyÃ©e hors de la boucle afin que vous puissiez l'utiliser:

```rust
fn main() {
    let mut counter = 0;
 
    let result = loop {
        counter += 1;
 
        if counter == 10 {
            break counter * 2;
        }
    };
 
    println!("The result is {result}");
}
```

#### While
```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");
        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```
#### For
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
 
    for element in a {
        println!("the value is: {element}");
    }
}
```
:::note
Pour en savoir plus, lisez le [chapitre 3](https://jimskapt.github.io/rust-book-fr/ch03-00-common-programming-concepts.html) qui se trouve dans la documentation au dÃ©but du TP!
:::

#### Structures
Les **structures** sont similaires aux tuples : elles contiennent tous les deux plusieurs valeurs liÃ©es. Comme les tuples, les parties composantes d'une structure peuvent avoir de diffÃ©rents types. Contrairement aux tuples, dans une structure, vous **nommez** chaque Ã©lÃ©ment de donnÃ©es afin que la signification des valeurs soit claire.

Pour **dÃ©finir** une structure, nous entrons le mot-clÃ© `struct` et nommons la structure entiÃ¨re. Le nom d'une structure doit dÃ©crire la signification des Ã©lÃ©ments de donnÃ©es regroupÃ©s. Ensuite, entre accolades, nous dÃ©finissons les noms et les types des donnÃ©es, que nous appelons **champs**.

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```
Pour utiliser une structure aprÃ¨s l'avoir dÃ©finie, nous crÃ©ons une **instance** de cette structure en spÃ©cifiant des valeurs concrÃ¨tes pour chacun des champs. Nous crÃ©ons une instance en indiquant le **nom** de la structure, puis ajoutons des accolades contenant des paires **clÃ© : valeur**, oÃ¹ les clÃ©s sont les noms des champs et les valeurs sont les donnÃ©es que nous voulons stocker dans ces champs.

```rust
fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}
```

Pour acceder a un certain membre du struct on utilise cette syntaxe:

```rust
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
 
    user1.email = String::from("anotheremail@example.com");
}
```
:::warning
Notez que l'instance entiÃ¨re doit Ãªtre **modifiable** ; Rust **ne nous permet** pas de marquer uniquement certains champs comme mutables!
:::

Comme pour toute expression, nous pouvons construire une nouvelle instance de la structure en tant que derniÃ¨re expression dans le corps de la fonction pour renvoyer implicitement cette nouvelle instance.

```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
```

#### Tuple structs
Rust prend Ã©galement en charge les structures qui ressemblent aux tuples, appelÃ©es **tuple structs**. Les structures de tuple ont la signification supplÃ©mentaire fournie par le nom de la structure mais n'ont pas de noms associÃ©s Ã  leurs champs ; au lieu de cela, ils ont juste les types des champs. Les structures de tuple sont utiles lorsque vous souhaitez donner un nom Ã  l'ensemble du tuple et lui donner un type diffÃ©rent des autres tuples, et lorsque nommer chaque champ comme dans une structure rÃ©guliÃ¨re serait verbeux ou redondant.

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
 
fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```
:::note 
Pour en savoir davantage, lisez le [chapitre 5](https://jimskapt.github.io/rust-book-fr/ch05-00-structs.html) qui se trouve dans la documentation au dÃ©but du TP!
:::

### Enums
Les Ã©numÃ©rations, Ã©galement appelÃ©es `enum`, vous permettent de dÃ©finir un type en Ã©numÃ©rant ses variantes possibles.
DÃ©finition d'une Ã©numÃ©rationÂ :

```rust
enum IpAddrKind {
    V4,
    V6,
}
```
#### Match

Rust dispose d'une construction de flux de contrÃ´le extrÃªmement puissante appelÃ©e Â« match Â» qui vous permet de comparer une valeur Ã  une sÃ©rie de modÃ¨les, puis d'exÃ©cuter du code en fonction du modÃ¨le qui correspond. Les modÃ¨les peuvent Ãªtre constituÃ©s de valeurs littÃ©rales, de noms de variables, de caractÃ¨res gÃ©nÃ©riques et bien d'autres Ã©lÃ©ments.

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}
 
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

Lorsque l'expression de correspondance s'exÃ©cute, elle compare la valeur rÃ©sultante au modÃ¨le pour chaque bras, dans l'ordre. Si un modÃ¨le correspond Ã  la valeur, le code associÃ© Ã  ce modÃ¨le est exÃ©cutÃ©. Si ce modÃ¨le ne correspond pas Ã  la valeur, l'exÃ©cution passe au bras suivant.

Le code associÃ© Ã  chaque bras est une **expression** et la valeur rÃ©sultante de l'expression dans le bras correspondant est la **valeur renvoyÃ©e** pour l'ensemble de l'expression correspondante.

Dans la section prÃ©cÃ©dente, nous voulions extraire la valeur `T` interne du cas Some lors de l'utilisation de `Option<T>`Â ; nous pouvons Ã©galement gÃ©rer `Option<T>` en utilisant match , comme nous l'avons fait avec l'Ã©numÃ©ration `Coin` ! Au lieu de comparer des parties, nous comparerons des variantes de `Option<T>`, mais le fonctionnement de l'expression `match` reste le mÃªme.
```rust
    fn get_option(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i),
        }
    }
 
    let five = Some(5);
    let six = get_option(five);
    let none = get_option(None);
```

:::info 

Pour une meilleure comprÃ©hension, veuillez lire le [chapitre 6](https://doc.rust-lang.org/book/ch06-00-enums.html) de la documentation.

:::

### String

Rust n'a qu'un seul type de chaÃ®ne dans le langage principal, qui est la tranche de chaÃ®ne `str` qui est gÃ©nÃ©ralement vue sous sa forme empruntÃ©e `&str`.

Le type `String`, qui est fourni par la bibliothÃ¨que standard Rust plutÃ´t que codÃ© dans le langage principal, est un type de chaÃ®ne codÃ© en UTF-8 Ã©volutif, mutable et dÃ©tenu(owned).

#### CrÃ©er une nouvelle String
```rust
    let mut s = String::new();
```
Cette ligne crÃ©e une nouvelle chaÃ®ne vide appelÃ©e `s`, dans laquelle nous pouvons ensuite charger des donnÃ©es.

Nous pouvons utiliser la fonction `String::from` ou la fonction `to_string` pour crÃ©er une chaÃ®ne Ã  partir d'une chaÃ®ne littÃ©raleÂ :

```rust
let s = String::from("initial contents");
```
```rust
let data = "initial contents";
 
let s = data.to_string();

// the method also works on a literal directly:
let s = "initial contents".to_string();
```

#### Ajouter des donnÃ©es Ã  une string
Nous pouvons dÃ©velopper une chaÃ®ne en utilisant la mÃ©thode `push_str` pour ajouter une tranche de chaÃ®ne.

```rust
let mut s = String::from("foo");
s.push_str("bar");
```

**La mÃ©thode push** prend **un seul caractÃ¨re** comme paramÃ¨tre et l'ajoute Ã  la chaÃ®ne.

```rust
let mut s = String::from("lo");
s.push('l');
```

#### MÃ©thodes d'itÃ©ration sur les Strings
La meilleure faÃ§on dâ€™opÃ©rer sur des morceaux de chaÃ®nes est dâ€™indiquer explicitement si vous voulez des caractÃ¨res ou des octets. Pour les valeurs scalaires Unicode individuelles, utilisez la mÃ©thode `chars`.
```rust
for c in "Ð—Ð´".chars() {
    println!("{c}");
}
```

#### ExÃ©cuter le programme
Pour exÃ©cuter le programme, nous pouvons Ãªtre n'importe oÃ¹ dans le dossier de la caisse et exÃ©cuter la commande.

```bash
cargo run
```

## Exercises
:::note
Avant d'aborder les exercices, jetez un Å“il et parcourez les chapitres [1](https://tourofrust.com/chapter_1_fr.html), [2](https://tourofrust.com/chapter_2_fr.html) et [3](https://tourofrust.com/chapter_3_fr.html) des tutoriels [Tour of Rust](https://tourofrust.com/00_fr.html).
:::

:::tip
Si Rust n'est pas installÃ©, vous pouvez utiliser [Rust Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021) pour rÃ©soudre les sujets.
:::

1. Ã‰crivez un programme qui imprime votre nom.
2. DÃ©finissez deux variables et attribuez-leur une valeur numÃ©rique. Affichez la valeur maximale entre les deux sans utiliser de variable temporaire.
3. Ã‰crivez une fonction qui vÃ©rifie si un nombre est divisible par n.
4. DÃ©finissez un tableau de nombres et Ã©crivez le code pour en afficher la valeur maximale.
5. DÃ©finissez une structure appelÃ©e Ordinateur qui dÃ©finit la marque, le nom du processeur et la taille de la mÃ©moire d'un ordinateur.
    a. Ecrivez une fonction associÃ©e (statique) appelÃ©e new qui crÃ©e une instance de la structure.
    b. Ã‰crivez une mÃ©thode appelÃ©e display qui imprime toutes les informations.
6. DÃ©finissez un tableau avec des Ã©lÃ©ments de type Ordinateur. Ã‰crivez un programme qui affiche un menu avec les options suivantes: a. imprimer tous les ordinateurs, b. imprimer l'ordinateur avec la plus grande quantitÃ© de mÃ©moire. Lisez les touches du clavier et exÃ©cutez l'option sÃ©lectionnÃ©e jusqu'Ã  ce que vous lisez quelque chose de diffÃ©rent de a et b.

:::tip
Utilisez [io::stdin().read_line(&mut buffer)](https://doc.rust-lang.org/std/io/fn.stdin.html) pour lire a partir du clavier.
:::

[^java_unsigned]: Ã€ partir de Java 8, les classes `Number` ont des mÃ©thodes d'assistance, comme `compareUnsigned` et `toUnsigned...` qui permettent l'utilisation et la manipulation de nombres non signÃ©s.
