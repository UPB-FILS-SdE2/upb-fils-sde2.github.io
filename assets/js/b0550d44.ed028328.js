"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4840],{2036:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>t,toc:()=>d});var i=n(7624),a=n(2172);const l={sidebar_position:8,description:"Fonctionnement de la m\xe9moire virtuelle, Inspection de la disposition de la m\xe9moire de processus (pmap), Mappage de fichiers et de pages vides en m\xe9moire"},r="TP 08 - Communication Entre Processus",t={id:"tp/08",title:"TP 08 - Communication Entre Processus",description:"Fonctionnement de la m\xe9moire virtuelle, Inspection de la disposition de la m\xe9moire de processus (pmap), Mappage de fichiers et de pages vides en m\xe9moire",source:"@site/docs/tp/08.md",sourceDirName:"tp",slug:"/tp/08",permalink:"/docs/tp/08",draft:!1,unlisted:!1,editUrl:"https://github.com/UPB-FILS-SdE2/upb-fils-sde2.github.io/edit/main/docs/tp/08.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8,description:"Fonctionnement de la m\xe9moire virtuelle, Inspection de la disposition de la m\xe9moire de processus (pmap), Mappage de fichiers et de pages vides en m\xe9moire"},sidebar:"tutorialSidebar",previous:{title:"TP 07 - Signaux",permalink:"/docs/tp/07"},next:{title:"Devoir",permalink:"/docs/category/devoir"}},o={},d=[{value:"Resources",id:"resources",level:2},{value:"Gestion de la m\xe9moire",id:"gestion-de-la-m\xe9moire",level:2},{value:"L&#39;espace d&#39;adressage d&#39;un processus",id:"lespace-dadressage-dun-processus",level:2},{value:"Zones de donn\xe9es",id:"zones-de-donn\xe9es",level:3},{value:".data",id:"data",level:4},{value:".bss",id:"bss",level:4},{value:".rodata",id:"rodata",level:4},{value:"Pile",id:"pile",level:3},{value:"Tas(Heap)",id:"tasheap",level:3},{value:"Allocation / affectation de m\xe9moire",id:"allocation--affectation-de-m\xe9moire",level:2},{value:"Allocation de m\xe9moire sous Linux",id:"allocation-de-m\xe9moire-sous-linux",level:3},{value:"M\xe9moire virtuelle",id:"m\xe9moire-virtuelle",level:2},{value:"Concepts th\xe9oriques",id:"concepts-th\xe9oriques",level:3},{value:"malloc",id:"malloc",level:3},{value:"Mappage de fichiers",id:"mappage-de-fichiers",level:3},{value:"mmap",id:"mmap",level:4},{value:"msync",id:"msync",level:4},{value:"Allouer de la m\xe9moire dans l&#39;espace d&#39;adressage du processus",id:"allouer-de-la-m\xe9moire-dans-lespace-dadressage-du-processus",level:3},{value:"Appareils de cartographie",id:"appareils-de-cartographie",level:3},{value:"Suppression d&#39;une zone de l&#39;espace d&#39;adressage",id:"suppression-dune-zone-de-lespace-dadressage",level:3},{value:"Redimensionner une zone mapp\xe9e",id:"redimensionner-une-zone-mapp\xe9e",level:3},{value:"Modifier la protection d&#39;une zone cartographi\xe9e",id:"modifier-la-protection-dune-zone-cartographi\xe9e",level:3},{value:"Exercises",id:"exercises",level:2}];function c(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.M)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h1,{id:"tp-08---communication-entre-processus",children:"TP 08 - Communication Entre Processus"}),"\n",(0,i.jsx)(s.h2,{id:"resources",children:"Resources"}),"\n",(0,i.jsx)(s.p,{children:"Fonctions de mappage de la m\xe9moire:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"https://docs.rs/nix/latest/nix/sys/mman/fn.mmap.html",children:"mmap"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"https://docs.rs/nix/latest/nix/sys/mman/fn.mprotect.html",children:"mprotect"})}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"https://docs.rs/nix/latest/nix/sys/mman/fn.munmap.html",children:"munmap"}),"\nIndicateurs de protection de la m\xe9moire:"]}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"https://docs.rs/nix/latest/nix/sys/mman/struct.ProtFlags.html",children:"ProtFlags"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"https://docs.rs/nix/latest/nix/sys/mman/struct.MapFlags.html",children:"MapFlags"})}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"gestion-de-la-m\xe9moire",children:"Gestion de la m\xe9moire"}),"\n",(0,i.jsx)(s.p,{children:"Le syst\xe8me de gestion de la m\xe9moire d'un syst\xe8me d'exploitation est utilis\xe9 par tous les autres sous-syst\xe8mes: planificateur, E / S, syst\xe8me de fichiers, gestion des processus, mise en r\xe9seau. La m\xe9moire est une ressource importante, c'est pourquoi des algorithmes efficaces pour son utilisation et sa gestion sont n\xe9cessaires."}),"\n",(0,i.jsx)(s.p,{children:"Le r\xf4le du sous-syst\xe8me de gestion de la m\xe9moire est de:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"garder une trace des zones de m\xe9moire physique (occup\xe9e ou libre)"}),"\n",(0,i.jsx)(s.li,{children:"pour fournir aux processus ou autres sous-syst\xe8mes un acc\xe8s \xe0 la m\xe9moire"}),"\n",(0,i.jsx)(s.li,{children:"mapper les pages de m\xe9moire virtuelle d'un processus (pages) sur les pages physiques (frames)"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Le noyau du syst\xe8me d'exploitation propose un ensemble d'interfaces (appels syst\xe8me) qui permettent l'allocation / partage de m\xe9moire, le mappage de r\xe9gions de m\xe9moire virtuelle sur des fichiers, le partage de zones de m\xe9moire."}),"\n",(0,i.jsx)(s.p,{children:"Malheureusement, le niveau limit\xe9 de compr\xe9hension de ces interfaces et des actions qui se produisent derri\xe8re elles conduit \xe0 un certain nombre de probl\xe8mes qui sont couramment rencontr\xe9s dans les applications logicielles: fuites de m\xe9moire, acc\xe8s invalides, \xe9crasement, d\xe9bordement de tampon, corruption de zone m\xe9moire."}),"\n",(0,i.jsx)(s.p,{children:"Il est donc essentiel de conna\xeetre le contexte dans lequel le sous-syst\xe8me de gestion de la m\xe9moire fonctionne et de comprendre l'interface fournie au programmeur par le syst\xe8me d'exploitation."}),"\n",(0,i.jsx)(s.h2,{id:"lespace-dadressage-dun-processus",children:"L'espace d'adressage d'un processus"}),"\n",(0,i.jsx)(s.p,{children:"L'espace d'adressage d'un processus ou, mieux encore, l'espace d'adressage virtuel d'un processus est la zone de m\xe9moire virtuelle qu'un processus peut utiliser. Chaque processus a son propre espace d'adressage. M\xeame dans les situations o\xf9 deux processus partagent une zone m\xe9moire, l'espace virtuel est distinct, mais il est mapp\xe9 sur la m\xeame zone m\xe9moire physique."}),"\n",(0,i.jsx)(s.p,{children:"La figure suivante montre un espace d'adressage typique pour un processus. Dans les syst\xe8mes d'exploitation modernes, dans l'espace virtuel de chaque processus, la m\xe9moire du noyau est mapp\xe9e, elle peut \xeatre mapp\xe9e au d\xe9but ou \xe0 la fin de l'espace d'adressage. Ensuite, nous ferons uniquement r\xe9f\xe9rence \xe0 l'espace d'adressage dans l'espace utilisateur pour un processus."}),"\n",(0,i.jsx)(s.p,{children:"Les 4 zones importantes de l'espace d'adressage du processus sont la zone de donn\xe9es, la zone de code, la pile et le tas. Comme le montre la figure, la pile et le tas sont les zones qui peuvent cro\xeetre. En fait, ces deux domaines sont dynamiques et n'ont de sens que dans le contexte d'un processus. De l'autre c\xf4t\xe9, les donn\xe9es dans la zone de donn\xe9es et la zone de code sont d\xe9crites dans l'ex\xe9cutable."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"L&#39;espace d&#39;adressage d&#39;un processus",src:n(8720).c+"",width:"337",height:"498"})}),"\n",(0,i.jsx)(s.h3,{id:"zones-de-donn\xe9es",children:"Zones de donn\xe9es"}),"\n",(0,i.jsx)(s.p,{children:"Les zones de donn\xe9es contiennent les variables globales d\xe9finies dans un programme et les variables en lecture seule. Il existe plusieurs sous-types de zones de donn\xe9es selon le type de donn\xe9es."}),"\n",(0,i.jsx)(s.h4,{id:"data",children:".data"}),"\n",(0,i.jsxs)(s.p,{children:["La zone ",(0,i.jsx)(s.code,{children:".data"})," contient les variables globales et les variables statiques ",(0,i.jsx)(s.strong,{children:"initialized"})," aux valeurs nulles d'un programme. Par exemple:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"static mut a: u32 = 3;\n"})}),"\n",(0,i.jsx)(s.h4,{id:"bss",children:".bss"}),"\n",(0,i.jsxs)(s.p,{children:["La zone ",(0,i.jsx)(s.code,{children:".bss"})," contient les variables globales et statiques ",(0,i.jsx)(s.strong,{children:"initialized"})," d'un programme. Avant l'ex\xe9cution du code, ce segment est initialis\xe9 avec 0. Par exemple:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"static mut a: u32 = 0;\n"})}),"\n",(0,i.jsxs)(s.p,{children:["En g\xe9n\xe9ral, ces variables ne seront pas pr\xe9allou\xe9es dans l'ex\xe9cutable, mais lors de la cr\xe9ation du processus. L'allocation de la zone ",(0,i.jsx)(s.code,{children:".bss"})," se fait sur des pages mises \xe0 z\xe9ro."]}),"\n",(0,i.jsx)(s.h4,{id:"rodata",children:".rodata"}),"\n",(0,i.jsxs)(s.p,{children:["La zone ",(0,i.jsx)(s.code,{children:".rodata"})," contient des informations qui ne peuvent \xeatre lues que et non modifi\xe9es. Voici les literals ",(0,i.jsx)(s.strong,{children:"stock\xe9s"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:'"Hello, World!"\n"En Taro Adun!"\n'})}),"\n",(0,i.jsxs)(s.p,{children:["Toutes les variables globales d\xe9clar\xe9es avec le mot-cl\xe9 ",(0,i.jsx)(s.code,{children:"const"})," seront sont align\xe9es dans leur lieu d'utilisation. Les variables locales d\xe9clar\xe9es seront plac\xe9es sur la pile, Un cas particulier est repr\xe9sent\xe9 par les variables locales constantes d\xe9clar\xe9es avec le mot-cl\xe9 ",(0,i.jsx)(s.code,{children:"static"})," qui seront mises dans le ",(0,i.jsx)(s.code,{children:".data"})," :"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"static mut a: u32 = 0;         /* dans .rodata */\n \nfn myfunc()\n{\n   let a: i32                       /* sur la pile */\n   let some_const: u32 = 2;       /* sur la pile */\n \n   static mut p: u32 = 8;    /* dans .data */\n   static p: u32 = 8;    /* dans .rodata */\n   ...\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"pile",children:"Pile"}),"\n",(0,i.jsx)(s.p,{children:"La pile est une r\xe9gion dynamique au sein d'un processus, g\xe9r\xe9e automatiquement par le compilateur."}),"\n",(0,i.jsx)(s.p,{children:"La pile est utilis\xe9e pour stocker des \u201ccadres de pile\u201d. Un nouveau \u201ccadre de pile\u201d sera cr\xe9\xe9 pour chaque appel de fonction."}),"\n",(0,i.jsx)(s.p,{children:"Un \u201ccadre de pile\u201d contient:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"variables locales"}),"\n",(0,i.jsx)(s.li,{children:"arguments de fonction"}),"\n",(0,i.jsx)(s.li,{children:"adresse de retour"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Sur la grande majorit\xe9 des architectures modernes, la pile cro\xeet (des grandes adresses aux petites adresses) et le tas augmente. La pile augmente \xe0 chaque appel de fonction et diminue \xe0 chaque retour de la fonction."}),"\n",(0,i.jsx)(s.p,{children:"La figure ci-dessous montre une vue conceptuelle sur la pile lors de l'appel d'une fonction."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"Pile d&#39;appel",src:n(9420).c+"",width:"518",height:"395"})}),"\n",(0,i.jsx)(s.h3,{id:"tasheap",children:"Tas(Heap)"}),"\n",(0,i.jsx)(s.p,{children:"Le tas est la zone de m\xe9moire d\xe9di\xe9e \xe0 l'allocation dynamique de m\xe9moire. Le segment de m\xe9moire est utilis\xe9 pour allouer des r\xe9gions de m\xe9moire dont la taille est d\xe9termin\xe9e lors de l'ex\xe9cution."}),"\n",(0,i.jsx)(s.p,{children:"Comme la pile, le tas est une r\xe9gion dynamique qui change sa taille. Contrairement \xe0 la pile, cependant, le tas n'est pas g\xe9r\xe9 par le compilateur. Il est du devoir du programmeur de savoir combien de m\xe9moire allouer et de se rappeler combien allouer et quand allouer. Les probl\xe8mes courants dans la plupart des programmes sont la perte de r\xe9f\xe9rences aux zones allou\xe9es (fuites de m\xe9moire) ou la r\xe9f\xe9rence de zones non allou\xe9es ou insuffisamment allou\xe9es (acc\xe8s invalides)."}),"\n",(0,i.jsx)(s.p,{children:"Dans des langages comme Java, Lisp, etc. l\xe0 o\xf9 il n'y a pas de \u201clibert\xe9 de pointeur\u201d, l'effacement de l'espace allou\xe9 se fait automatiquement via un garbage collector. Sur ces syst\xe8mes, le probl\xe8me de la perte de r\xe9f\xe9rences est \xe9vit\xe9, mais le probl\xe8me de r\xe9f\xe9rence de zones non allou\xe9es reste actif."}),"\n",(0,i.jsx)(s.h2,{id:"allocation--affectation-de-m\xe9moire",children:"Allocation / affectation de m\xe9moire"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"L'allocation de m\xe9moire"})," est effectu\xe9e statiquement par le compilateur ou dynamiquement pendant l'ex\xe9cution. L'allocation statique est effectu\xe9e dans des segments de donn\xe9es pour les variables globales ou pour les litt\xe9raux."]}),"\n",(0,i.jsxs)(s.p,{children:["Lors de l'ex\xe9cution, les variables sont allou\xe9es sur la pile ou dans le tas. L'allocation de pile est automatiquement effectu\xe9e par le compilateur pour les variables locales d'une fonction (\xe0 l'exception des variables locales pr\xe9fix\xe9es par l'identifiant ",(0,i.jsx)(s.strong,{children:"statique"}),")."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.em,{children:"L'allocation dynamique"})," se fait en tas. L'allocation dynamique se produit quand on ne sait pas, au moment de la compilation, combien de m\xe9moire sera n\xe9cessaire pour une variable, une structure, un vecteur. Si, au moment de la compilation, on sait combien d'espace une variable occupera, son allocation statique est recommand\xe9e, afin d'\xe9viter les erreurs qui se produisent fr\xe9quemment dans le contexte de l'allocation dynamique."]}),"\n",(0,i.jsx)(s.p,{children:"Afin de fragmenter le moins possible l'espace d'adressage du processus, \xe0 la suite d'allocations et de d\xe9sallocations de zones de diff\xe9rentes tailles, l'allocateur de m\xe9moire organisera le segment de donn\xe9es allou\xe9 dynamiquement en tas , d'o\xf9 le nom du segment."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"D\xe9bordement de m\xe9moire"})," signifie lib\xe9rer de la zone de m\xe9moire pr\xe9c\xe9demment allou\xe9e (elle est marqu\xe9e comme libre)."]}),"\n",(0,i.jsx)(s.p,{children:"Si le verrouillage d'une zone m\xe9moire est omis, il restera allou\xe9 pendant toute la dur\xe9e d'ex\xe9cution du processus. Chaque fois qu'une zone m\xe9moire n'est plus n\xe9cessaire, elle doit \xeatre compens\xe9e pour l'efficacit\xe9 d'utilisation de l'espace m\xe9moire."}),"\n",(0,i.jsxs)(s.p,{children:["Il n'est pas n\xe9cessaire de traiter diff\xe9rents domaines avant un appel ",(0,i.jsx)(s.a,{href:"https://linux.die.net/man/3/exit",children:"exit"})," ou avant la fin du programme car ils sont automatiquement lib\xe9r\xe9s par le syst\xe8me d'exploitation."]}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsx)(s.p,{children:"Dans la plupart des cas, des probl\xe8mes surviennent si vous essayez de colocaliser deux fois la m\xeame zone de m\xe9moire. En effet, les donn\xe9es de gestion interne des zones allou\xe9es sont corrompues. Habituellement, le noyau signale le probl\xe8me avec une interruption synchrone."})}),"\n",(0,i.jsx)(s.h3,{id:"allocation-de-m\xe9moire-sous-linux",children:"Allocation de m\xe9moire sous Linux"}),"\n",(0,i.jsxs)(s.p,{children:["Sous Linux, l'allocation de m\xe9moire pour les processus utilisateur se fait via les fonctions de biblioth\xe8que ",(0,i.jsx)(s.a,{href:"https://linux.die.net/man/3/malloc",children:"malloc"}),", ",(0,i.jsx)(s.a,{href:"https://linux.die.net/man/3/calloc",children:"calloc"})," et ",(0,i.jsx)(s.a,{href:"https://linux.die.net/man/3/realloc",children:"realloc"}),", et sa collocation \xe0 travers la fonction ",(0,i.jsx)(s.a,{href:"https://linux.die.net/man/3/free",children:"free"}),". Ces fonctions repr\xe9sentent les appels de biblioth\xe8que et r\xe9solvent, dans la mesure du possible, l'allocation de m\xe9moire et les demandes d'allocation dans l'espace utilisateur."]}),"\n",(0,i.jsx)(s.h2,{id:"m\xe9moire-virtuelle",children:"M\xe9moire virtuelle"}),"\n",(0,i.jsx)(s.admonition,{type:"warning",children:(0,i.jsx)(s.p,{children:"Vous pouvez trouver dans la section Bibliographie les liens pour les fonctions de Rust qui sont correspondant aux fonctions de C utilisees par Linux. S'il vous plait de les consulter!"})}),"\n",(0,i.jsx)(s.p,{children:"Le m\xe9canisme de m\xe9moire virtuelle est utilis\xe9 par le c\u0153ur du syst\xe8me d'exploitation pour impl\xe9menter une politique de gestion de m\xe9moire efficace. Ainsi, bien que les applications utilisent actuellement la m\xe9moire virtuelle, elles ne le font pas explicitement. Cependant, dans certains cas, les applications utilisent explicitement la m\xe9moire virtuelle."}),"\n",(0,i.jsx)(s.p,{children:"Le syst\xe8me d'exploitation fournit des primitives pour mapper des fichiers, de la m\xe9moire ou des p\xe9riph\xe9riques \xe0 l'espace d'adressage d'un processus."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Le mappage de fichiers"})," en m\xe9moire est utilis\xe9 dans certains syst\xe8mes d'exploitation pour impl\xe9menter des m\xe9canismes de m\xe9moire partag\xe9e. De plus, ce m\xe9canisme permet d'impl\xe9menter la pagination \xe0 la demande et des biblioth\xe8ques partag\xe9es."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Le mappage de la m\xe9moire"})," dans l'espace d'adressage est utile lorsqu'un processus souhaite allouer une grande quantit\xe9 de m\xe9moire."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Le mappage d'appareil"})," est utile lorsqu'un processus souhaite utiliser directement la m\xe9moire d'un appareil (comme une carte vid\xe9o)."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"concepts-th\xe9oriques",children:"Concepts th\xe9oriques"}),"\n",(0,i.jsx)(s.p,{children:"La taille de l'espace d'adressage virtuel d'un processus d\xe9pend de la taille des registres du processeur. Ainsi, sur un syst\xe8me 32 bits, un processus pourra acc\xe9der \xe0 2 ^ 32 = 4 Go d'espace m\xe9moire (en revanche, sur un syst\xe8me 64 bits, il acc\xe9dera th\xe9oriquement \xe0 2 ^ 64 B). L'espace m\xe9moire du processus est divis\xe9 en un espace r\xe9serv\xe9 aux adresses de noyau virtuel - cet espace est commun \xe0 tous les processus - et l'espace d'adressage virtuel (propre) du processus. La plupart du temps, le partage entre les deux est de 3/1 (3 Go d'espace utilisateur contre 1 Go d'espace noyau)."}),"\n",(0,i.jsx)(s.p,{children:"La m\xe9moire physique (RAM) est r\xe9partie entre les processus actuellement actifs et le syst\xe8me d'exploitation. Ainsi, selon la quantit\xe9 de m\xe9moire dont nous disposons sur la machine physique, il est possible d'\xe9puiser toutes les ressources et de ne pas pouvoir d\xe9marrer un nouveau processus. Pour \xe9viter ce sc\xe9nario, le m\xe9canisme de m\xe9moire virtuelle a \xe9t\xe9 introduit. De cette fa\xe7on, m\xeame si l'espace virtuel (compos\xe9 du segment de texte, de la date, du tas, de la pile) d'un processus est plus grand que la m\xe9moire physique disponible sur le syst\xe8me, le processus pourra s'ex\xe9cuter en m\xe9moire en ne chargeant que les pages dont il a besoin dans temps d'ex\xe9cution (paging \xe0 la demande)."}),"\n",(0,i.jsx)(s.p,{children:"L'espace d'adressage virtuel est divis\xe9 en pages virtuelles (page). Le correspondant de la m\xe9moire physique est la page physique (frame). La taille d'une page virtuelle est \xe9gale \xe0 celle d'une page physique. La taille est donn\xe9e par le mat\xe9riel (dans la plupart des cas, une page a 4 Ko sur un syst\xe8me 32 bits ou 64 bits)."}),"\n",(0,i.jsx)(s.p,{children:"Tant qu'un processus en cours d'ex\xe9cution n'acc\xe8de qu'aux pages r\xe9sidant en m\xe9moire, il s'ex\xe9cute comme s'il avait tout l'espace mapp\xe9 dans la m\xe9moire physique. Lorsqu'un processus souhaite acc\xe9der \xe0 une certaine page virtuelle, qui n'est pas mapp\xe9e en m\xe9moire, une erreur de page sera g\xe9n\xe9r\xe9e, et apr\xe8s cette page manquante, la page virtuelle sera mapp\xe9e sur une page physique. Deux processus diff\xe9rents ont un espace virtuel diff\xe9rent, mais certaines pages virtuelles de ces processus peuvent \xeatre mapp\xe9es sur la m\xeame page physique. Ainsi, deux processus diff\xe9rents peuvent partager la m\xeame page physique, mais ne partagent pas de pages virtuelles."}),"\n",(0,i.jsx)(s.h3,{id:"malloc",children:"malloc"}),"\n",(0,i.jsxs)(s.p,{children:["Comme nous l'avons trouv\xe9 dans la section Allocation de m\xe9moire sous Linux, ",(0,i.jsx)(s.code,{children:"malloc"})," alloue de la m\xe9moire sur le tas, donc dans l'espace virtuel du processus."]}),"\n",(0,i.jsxs)(s.p,{children:["L'allocation de m\xe9moire virtuelle se fait au niveau de la page, de sorte que ",(0,i.jsx)(s.code,{children:"malloc"})," alloue r\xe9ellement le plus petit nombre de pages virtuelles qui composent l'espace m\xe9moire requis. Soit le code suivant:"]}),"\n",(0,i.jsxs)(s.p,{children:["Rust utilise la fonction ",(0,i.jsx)(s.code,{children:"malloc"})," de la ",(0,i.jsx)(s.code,{children:"libc"})," pour allouer de la m\xe9moire lors de l'utilisation, par exemple, de ",(0,i.jsx)(s.code,{children:"Vec::new()"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:'char *p = malloc(4150);\nDIE(p == NULL, "malloc failed");\n'})}),"\n",(0,i.jsxs)(s.p,{children:["\xc9tant donn\xe9 qu'une page virtuelle a 4KB = 4096 octets, alors l'appel ",(0,i.jsx)(s.code,{children:"malloc"})," allouera 4096 octets + 54 octets = 4KB + 54 octets, espace qui n'est pas contenu dans une seule page virtuelle, de sorte que 2 pages seront allou\xe9es virtuel. Au moment de l'affectation avec \u201cmalloc\u201d il n'y aura pas de pages allou\xe9es (tout le temps) et physiques; ils ne seront allou\xe9s que lors de l'acc\xe8s aux donn\xe9es de la zone de m\xe9moire allou\xe9e avec 'malloc'. Par exemple, lors de l'acc\xe8s \xe0 un \xe9l\xe9ment \xe0 partir de p, une erreur de page sera g\xe9n\xe9r\xe9e et la page virtuelle contenant cet \xe9l\xe9ment sera mapp\xe9e sur une page physique."]}),"\n",(0,i.jsxs)(s.admonition,{type:"note",children:[(0,i.jsxs)(s.p,{children:["G\xe9n\xe9ralement, sur le petit appel malloc (lorsque l'appel syst\xe8me ",(0,i.jsx)(s.code,{children:"brk"})," est rappel\xe9), la biblioth\xe8que C standard analyse les pages allou\xe9es, g\xe9n\xe8re des erreurs de page et lorsque l'appel revient, les pages physiques seront d\xe9j\xe0 allou\xe9es. On peut dire que pour les petites dimensions, l'appel 'malloc', vu depuis l'application (en dehors de la biblioth\xe8que standard C), alloue \xe9galement des pages physiques et des pages virtuelles."]}),(0,i.jsxs)(s.p,{children:["De plus, l'allocation r\xe9elle des pages virtuelles et physiques se produit au moment de l'appel syst\xe8me ",(0,i.jsx)(s.code,{children:"brk"})," . Il alloue un espace plus grand, et les futurs appels ",(0,i.jsx)(s.code,{children:"malloc"})," utiliseront cet espace. De cette fa\xe7on, les appels \u201cmalloc\u201d suivants seront efficaces: ils ne feront pas d'appels syst\xe8me, ils ne feront pas d'allocation efficace d'espace virtuel ou physique, ils ne g\xe9n\xe9reront pas de d\xe9fauts de page ."]}),(0,i.jsxs)(s.p,{children:["L'appel malloc est plus efficace que l'appel calloc car il ne parcourt pas l'espace allou\xe9 pour le remplir de z\xe9ros. Cela signifie que ",(0,i.jsx)(s.code,{children:"malloc"})," renverra la zone allou\xe9e avec les informations qui s'y trouvent; Dans certaines situations, cela peut constituer un risque pour la s\xe9curit\xe9 - si les donn\xe9es y sont priv\xe9es."]})]}),"\n",(0,i.jsx)(s.h3,{id:"mappage-de-fichiers",children:"Mappage de fichiers"}),"\n",(0,i.jsxs)(s.p,{children:["Apr\xe8s avoir mapp\xe9 un fichier \xe0 l'espace d'adressage du processus, l'acc\xe8s \xe0 ce fichier peut se faire de la m\xeame mani\xe8re que l'acc\xe8s aux donn\xe9es \xe0 partir d'un vecteur. L'efficacit\xe9 de la m\xe9thode vient du fait que la zone m\xe9moire est g\xe9r\xe9e de la m\xeame mani\xe8re que la m\xe9moire virtuelle, soumise aux r\xe8gles d'\xe9vacuation du disque lorsque la m\xe9moire devient insuffisante (de cette fa\xe7on on peut travailler avec des mappages qui d\xe9passent la taille effective de la m\xe9moire physique). De plus, la partie ",(0,i.jsx)(s.code,{children:"I / O"})," est r\xe9alis\xe9e par le noyau, le programmeur \xe9crivant du code qui ne r\xe9cup\xe8re / stocke que les valeurs de / dans la r\xe9gion mapp\xe9e. Ainsi, il n'est plus appel\xe9 ",(0,i.jsx)(s.code,{children:"read"})," , ",(0,i.jsx)(s.code,{children:"write"})," , ",(0,i.jsx)(s.code,{children:"lseek"})," - ce qui simplifie souvent l'\xe9criture de code."]}),"\n",(0,i.jsx)(s.admonition,{type:"warning",children:(0,i.jsxs)(s.p,{children:["Tous les descripteurs de fichiers ne peuvent pas \xeatre mapp\xe9s en m\xe9moire. Les sockets, les tuyaux, les p\xe9riph\xe9riques qui n'autorisent que l'acc\xe8s s\xe9quentiel (par exemple, le p\xe9riph\xe9rique char) sont incompatibles avec les concepts de mappage. Il existe des cas o\xf9 les fichiers normaux ne peuvent pas \xeatre mapp\xe9s (par exemple, s'ils n'\xe9taient pas ouverts pour plus de lisibilit\xe9; pour plus d'informations: ",(0,i.jsx)(s.strong,{children:"man mmap"})," )."]})}),"\n",(0,i.jsx)(s.h4,{id:"mmap",children:"mmap"}),"\n",(0,i.jsx)(s.p,{children:"Prototype de fonction mmap qui permet le mappage d'un fichier \xe0 l'espace d'adressage du processus est le suivant:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c",children:"void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\n"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"pub unsafe fn mmap(\n    addr: Option<NonZeroUsize>,\n    length: NonZeroUsize,\n    prot: ProtFlags,\n    flags: MapFlags,\n    fd: RawFd,\n    offset: off_t\n) -> Result<*mut c_void>\n"})}),"\n",(0,i.jsxs)(s.p,{children:["La fonction retournera en cas d'erreur ",(0,i.jsx)(s.code,{children:"MAP_FAILED"})," . Si le mappage a r\xe9ussi, il renverra un pointeur vers une zone de m\xe9moire dans l'espace d'adressage du processus, la zone o\xf9 le fichier d\xe9crit par le descripteur ",(0,i.jsx)(s.code,{children:"fd"})," a \xe9t\xe9 mapp\xe9, en commen\xe7ant par l'offset. L'utilisation du param\xe8tre ",(0,i.jsx)(s.code,{children:"start"})," vous permet de proposer une zone m\xe9moire sp\xe9cifique \xe0 mapper. L'utilisation de la valeur NULL pour le param\xe8tre start indique l'absence de pr\xe9f\xe9rence concernant la zone dans laquelle l'allocation sera effectu\xe9e. L'adresse sp\xe9cifi\xe9e par le param\xe8tre start doit \xeatre multiple de la taille d'une page . Si le syst\xe8me d'exploitation ne peut pas mapper le fichier \xe0 l'adresse requise, il le mappera \xe0 un emplacement proche et multiple de ",(0,i.jsx)(s.em,{children:"la taille d'une page"}),". L'adresse la plus appropri\xe9e est \xe9galement retourn\xe9e."]}),"\n",(0,i.jsxs)(s.p,{children:["Le param\xe8tre ",(0,i.jsx)(s.code,{children:"prot"})," sp\xe9cifie le type d'acc\xe8s souhait\xe9:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"PROT_READ"})," (lire)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"PROT_WRITE"})," (\xe9crire)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"PROT_EXEC"})," (ex\xe9cution)"]}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"PROT_NONE"})}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["Lorsque la zone est utilis\xe9e autrement que ce qui est indiqu\xe9, un signal ",(0,i.jsx)(s.code,{children:"SIGSEGV"})," est g\xe9n\xe9r\xe9."]}),"\n",(0,i.jsxs)(s.p,{children:["Le param\xe8tre ",(0,i.jsx)(s.code,{children:"flags"})," vous permet de d\xe9finir le type de mappage que vous souhaitez; il peut prendre les valeurs suivantes (combin\xe9es par OR en bits; il doit y avoir au moins ",(0,i.jsx)(s.code,{children:"MAP_PRIVATE"})," ou ",(0,i.jsx)(s.code,{children:"MAP_SHARED"})," ):"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"MAP_PRIVATE"})," - Utilisez une politique de copie sur \xe9criture . La zone contiendra initialement une copie du fichier, mais les \xe9critures ne sont pas effectu\xe9es dans le fichier. Les modifications ne seront pas visibles dans les autres processus , s'il y a plusieurs processus qui ont fait \u201cmmap\u201d sur la m\xeame zone du m\xeame fichier."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"MAP_SHARED"})," - Les entr\xe9es sont mises \xe0 jour imm\xe9diatement dans tous les mappages existants. De cette fa\xe7on, tous les processus qui ont effectu\xe9 des mappages verront les modifications. En effet, les mappages \u201cMAP_SHARED\u201d sont effectu\xe9s sur les pages physiques du cache de pages et les appels r / w utilisent les pages physiques du cache de pages pour r\xe9duire le nombre de lectures / \xe9critures \xe0 partir du disque. Les mises \xe0 jour du disque auront lieu ult\xe9rieurement, sans pr\xe9cision."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"MAP_FIXED"})," - Si l'affectation \xe0 l'adresse sp\xe9cifi\xe9e par start ne peut pas \xeatre effectu\xe9e, l'appel \xe9chouera."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"MAP_LOCKED"})," - Cette page sera bloqu\xe9e de cette mani\xe8re ",(0,i.jsx)(s.a,{href:"https://linux.die.net/man/2/mlock",children:"mlock"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"MAP_ANONYMOUS"})," - Mappe la RAM (les arguments fd et offset sont ignor\xe9s)."]}),"\n",(0,i.jsxs)(s.p,{children:["Il est \xe0 noter que l'utilisation de ",(0,i.jsx)(s.code,{children:"MAP_SHARED"})," permet le partage de m\xe9moire entre des processus qui ne sont pas li\xe9s. Dans ce cas, le contenu du fichier devient le contenu initial de la m\xe9moire partag\xe9e et toutes les modifications apport\xe9es par les processus dans cette zone sont ensuite copi\xe9es dans le fichier, garantissant ainsi la persistance dans le syst\xe8me de fichiers."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"msync",children:"msync"}),"\n",(0,i.jsxs)(s.p,{children:["La fonctionnalit\xe9 est disponible pour d\xe9clencher explicitement la synchronisation des fichiers avec le mappage de la m\xe9moire ",(0,i.jsx)(s.a,{href:"https://linux.die.net/man/2/msync",children:"msync"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c",children:"int msync(void *start, size_t length, int flags);\n"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"pub unsafe fn msync(\n    addr: *mut c_void,\n    length: size_t,\n    flags: MsFlags\n) -> Result<()>\n"})}),"\n",(0,i.jsxs)(s.p,{children:["o\xf9 ",(0,i.jsx)(s.code,{children:"drapeaux"})," peut \xeatre:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"MS_SYNC"})," - Les donn\xe9es seront \xe9crites dans le fichier et attendront jusqu'\xe0 ce qu'elles soient termin\xe9es."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"MS_ASYNC"})," - La s\xe9quence de sauvegarde est lanc\xe9e, mais son ach\xe8vement n'est pas pr\xe9vu."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"MS_INVALIDATE"})," - Le mappage de la zone \xe0 partir d'autres processus est invalid\xe9, de sorte que les processus seront mis \xe0 jour avec les nouvelles donn\xe9es entr\xe9es."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"L'appel msync est utile pour \xe9crire des pages modifi\xe9es du cache de pages sur le disque, afin d'\xe9viter de perdre des modifications en cas de plantage du syst\xe8me."}),"\n",(0,i.jsx)(s.h3,{id:"allouer-de-la-m\xe9moire-dans-lespace-dadressage-du-processus",children:"Allouer de la m\xe9moire dans l'espace d'adressage du processus"}),"\n",(0,i.jsxs)(s.p,{children:["Sous UNIX, traditionnellement, pour l'allocation de m\xe9moire dynamique , l'appel syst\xe8me est utilis\xe9 ",(0,i.jsx)(s.a,{href:"https://linux.die.net/man/2/brk",children:"brk"}),". Cet appel augmente ou diminue la zone de segment de m\xe9moire associ\xe9e au processus. Avec la fourniture d'appels du syst\xe8me de gestion de la m\xe9moire virtuelle aux applications (",(0,i.jsx)(s.a,{href:"https://linux.die.net/man/2/mmap",children:"mmap"}),"), il \xe9tait possible pour les processus d'allouer de la m\xe9moire \xe0 l'aide de ces nouveaux appels syst\xe8me. Fondamentalement, les processus peuvent mapper la m\xe9moire \xe0 l'espace d'adressage, pas aux fichiers."]}),"\n",(0,i.jsxs)(s.p,{children:["Les processus peuvent n\xe9cessiter l'allocation d'une zone m\xe9moire \xe0 partir d'une adresse sp\xe9cifique dans l'espace adresse, m\xeame avec une certaine strat\xe9gie d'acc\xe8s (lecture, \xe9criture ou ex\xe9cution). Sous UNIX, cela se fait \xe9galement via la fonction mmap. Pour cela, le param\xe8tre ",(0,i.jsx)(s.code,{children:"flags"})," doit contenir le flag ",(0,i.jsx)(s.code,{children:"MAP_ANONYMOUS"})," ."]}),"\n",(0,i.jsx)(s.h3,{id:"appareils-de-cartographie",children:"Appareils de cartographie"}),"\n",(0,i.jsxs)(s.p,{children:["Il est m\xeame possible pour les applications de mapper un p\xe9riph\xe9rique d'entr\xe9e-sortie dans l'espace d'adressage du processus. Ceci est utile, par exemple, pour les cartes vid\xe9o: une application peut mapper la m\xe9moire physique de la carte vid\xe9o \xe0 l'espace d'adressage. Sous UNIX, les p\xe9riph\xe9riques \xe9tant repr\xe9sent\xe9s par des fichiers, il suffit pour cela d'ouvrir le fichier associ\xe9 au p\xe9riph\xe9rique et de l'utiliser dans un appel ",(0,i.jsx)(s.code,{children:"mmap"})," ."]}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsx)(s.p,{children:"Tous les appareils ne peuvent pas \xeatre mapp\xe9s en m\xe9moire, mais lorsqu'ils sont mapp\xe9s, l'importance de ce mappage d\xe9pend strictement de l'appareil."})}),"\n",(0,i.jsxs)(s.p,{children:["Un autre exemple d'un p\xe9riph\xe9rique qui peut \xeatre mapp\xe9 est la m\xe9moire elle-m\xeame. Sous Linux, vous pouvez utiliser le fichier ",(0,i.jsx)(s.code,{children:"/ dev / zero"})," pour effectuer le mappage de la m\xe9moire, comme si vous utilisiez l'indicateur ",(0,i.jsx)(s.code,{children:"MAP_ANONYMOUS"})," ."]}),"\n",(0,i.jsx)(s.h3,{id:"suppression-dune-zone-de-lespace-dadressage",children:"Suppression d'une zone de l'espace d'adressage"}),"\n",(0,i.jsxs)(s.p,{children:["Si vous souhaitez effacer une zone de l'espace d'adressage du processus, vous pouvez utiliser la fonction ",(0,i.jsx)(s.a,{href:"https://linux.die.net/man/3/munmap",children:"munmap"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c",children:" int munmap(void *start, size_t length);\n"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"pub unsafe fn munmap(addr: *mut c_void, len: size_t) -> Result<()>\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"addr"})," est l'adresse de la premi\xe8re page \xe0 d\xe9limiter (doit \xeatre multiple de la taille d'une page ). Si la ",(0,i.jsx)(s.code,{children:"longueur"})," n'est pas une taille qui repr\xe9sente un nombre entier de pages, elle sera arrondie plus haut. La zone peut contenir des pi\xe8ces qui ont d\xe9j\xe0 \xe9t\xe9 supprim\xe9es. Vous pouvez ainsi effacer plusieurs zones en m\xeame temps."]}),"\n",(0,i.jsx)(s.h3,{id:"redimensionner-une-zone-mapp\xe9e",children:"Redimensionner une zone mapp\xe9e"}),"\n",(0,i.jsxs)(s.p,{children:["La fonction peut \xeatre utilis\xe9e pour effectuer des op\xe9rations de redimensionnement de la zone de mappage ",(0,i.jsx)(s.a,{href:"https://linux.die.net/man/2/mremap",children:"mremap"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c",children:"void *mremap(void *old_address, size_t old_size, size_t new_size, unsigned long flags);\n"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"pub unsafe fn mremap(\n    addr: *mut c_void,\n    old_size: size_t,\n    new_size: size_t,\n    flags: MRemapFlags,\n    new_address: Option<*mut c_void>\n) -> Result<*mut c_void>\n"})}),"\n",(0,i.jsxs)(s.p,{children:["La zone d\xe9crite par ",(0,i.jsx)(s.code,{children:"addr"})," et ",(0,i.jsx)(s.code,{children:"old_size"})," doit appartenir \xe0 un seul mappage. Une seule option est disponible pour les ",(0,i.jsx)(s.code,{children:"indicateurs"})," : ",(0,i.jsx)(s.code,{children:"MREMAP_MAYMOVE"})," qui montre qu'il est correct d'obtenir le nouveau mappage pour effectuer un nouveau mappage dans une autre zone de m\xe9moire (l'ancienne zone \xe9tant floue)."]}),"\n",(0,i.jsx)(s.h3,{id:"modifier-la-protection-dune-zone-cartographi\xe9e",children:"Modifier la protection d'une zone cartographi\xe9e"}),"\n",(0,i.jsxs)(s.p,{children:["Parfois, il est n\xe9cessaire de changer la fa\xe7on (droits d'acc\xe8s) dans laquelle une zone a \xe9t\xe9 cartographi\xe9e. Pour cela, vous pouvez utiliser la fonction ",(0,i.jsx)(s.a,{href:"https://linux.die.net/man/2/mprotect",children:"mprotect"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-c",children:"int mprotect(const void *addr, size_t len, int prot);\n"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-rust",children:"pub unsafe fn mprotect(\n    addr: *mut c_void,\n    length: size_t,\n    prot: ProtFlags\n) -> Result<()>\n"})}),"\n",(0,i.jsxs)(s.p,{children:["La fonction re\xe7oit comme param\xe8tres la plage d'adresses [ ",(0,i.jsx)(s.code,{children:"addr"})," , ",(0,i.jsx)(s.code,{children:"addr + length - 1"}),"] et de nouveaux droits d'acc\xe8s ( ",(0,i.jsx)(s.code,{children:"PROT_READ"})," , ",(0,i.jsx)(s.code,{children:"PROT_WRITE"})," , ",(0,i.jsx)(s.code,{children:"PROT_EXEC"})," ,",(0,i.jsx)(s.code,{children:"PROT_NONE"}),"). Comme dans munmap, ",(0,i.jsx)(s.code,{children:"addr"})," doit \xeatre multiple de la taille de la page . La fonction modifiera la protection de toutes les pages contenant au moins un octet dans la plage sp\xe9cifi\xe9e."]}),"\n",(0,i.jsx)(s.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"Ex\xe9cutez le programme dans ex1. R\xe9pondez aux questions pos\xe9es par le programme."}),"\n",(0,i.jsx)(s.li,{children:"R\xe9solvez les lignes TODO (dans l'ordre) \xe0 partir de ex1."}),"\n",(0,i.jsx)(s.li,{children:"R\xe9solvez les lignes TODO (dans l'ordre) de ex2."}),"\n",(0,i.jsx)(s.li,{children:"R\xe9solvez les lignes TODO (dans l'ordre) de ex3."}),"\n"]})]})}function u(e={}){const{wrapper:s}={...(0,a.M)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},9420:(e,s,n)=>{n.d(s,{c:()=>i});const i=n.p+"assets/images/call_stack-f6a8dfe5fec12e6a96e7d1dd3643db8d.jpg"},8720:(e,s,n)=>{n.d(s,{c:()=>i});const i=n.p+"assets/images/process_address_space-128650d74129271b444d496efdccd296.jpg"},2172:(e,s,n)=>{n.d(s,{I:()=>t,M:()=>r});var i=n(1504);const a={},l=i.createContext(a);function r(e){const s=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(l.Provider,{value:s},e.children)}}}]);