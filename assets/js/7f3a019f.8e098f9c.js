"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3002],{6628:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var i=s(7624),t=s(2172);const r={sidebar_position:7,description:"Utilisation des signaux"},l="TP 07 - Signaux",o={id:"tp/07",title:"TP 07 - Signaux",description:"Utilisation des signaux",source:"@site/docs/tp/07.md",sourceDirName:"tp",slug:"/tp/07",permalink:"/docs/tp/07",draft:!1,unlisted:!1,editUrl:"https://github.com/UPB-FILS-SdE2/upb-fils-sde2.github.io/edit/main/docs/tp/07.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,description:"Utilisation des signaux"},sidebar:"tutorialSidebar",previous:{title:"TP 06 - Communication Entre Processus",permalink:"/docs/tp/06"},next:{title:"TP 08 - Communication Entre Processus",permalink:"/docs/tp/08"}},a={},d=[{value:"Resources",id:"resources",level:2},{value:"Signaux en Rust",id:"signaux-en-rust",level:2},{value:"Emission et r\xe9ception de signaux",id:"emission-et-r\xe9ception-de-signaux",level:3},{value:"Types de signaux standard",id:"types-de-signaux-standard",level:3},{value:"Tuer des processus",id:"tuer-des-processus",level:2},{value:"Suggestions",id:"suggestions",level:2},{value:"Exercises",id:"exercises",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.M)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"tp-07---signaux",children:"TP 07 - Signaux"}),"\n",(0,i.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.rs/nix/latest/nix/unistd/fn.pipe.html",children:"Pipe"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.rs/nix/latest/nix/sys/signal/fn.kill.html",children:"Kill"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.rs/nix/latest/nix/sys/signal/fn.signal.html",children:"Signal"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"signaux-en-rust",children:"Signaux en Rust"}),"\n",(0,i.jsxs)(n.p,{children:["Les processus tels que les applications en ligne de commande doivent ",(0,i.jsx)(n.strong,{children:"r\xe9agir"})," aux signaux envoy\xe9s par le syst\xe8me d'exploitation. L'exemple le plus courant est probablement ",(0,i.jsx)(n.code,{children:"Ctrl + C"}),", le signal qui indique g\xe9n\xe9ralement \xe0 un processus de se terminer. Pour g\xe9rer les signaux dans les programmes Rust, vous devez consid\xe9rer comment vous pouvez recevoir ces signaux ainsi que comment vous pouvez y r\xe9agir."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"Un signal est une interruption logicielle dans le flux d'ex\xe9cution de processus normal."})}),"\n",(0,i.jsx)(n.p,{children:"L'ensemble des types de signaux est fini; le syst\xe8me d'exploitation conserve, pour chaque processus, un tableau d'actions choisi par lui, pour chaque type de signal. \xc0 tout moment, ces actions sont bien d\xe9termin\xe9es. Au d\xe9but du processus, la table d'actions est initialis\xe9e avec les valeurs par d\xe9faut. Le mode de traitement du signal n'est pas d\xe9cid\xe9 lors de la r\xe9ception du signal par le processus, mais il est automatiquement choisi dans le tableau. Les signaux sont synchrones / asynchrones avec le flux d'ex\xe9cution de processus qui re\xe7oit le signal si l'\xe9v\xe9nement qui provoque l'envoi du signal est synchrone / asynchrone avec le flux d'ex\xe9cution de processus."}),"\n",(0,i.jsx)(n.h3,{id:"emission-et-r\xe9ception-de-signaux",children:"Emission et r\xe9ception de signaux"}),"\n",(0,i.jsxs)(n.p,{children:["Lorsqu'un signal est g\xe9n\xe9r\xe9, il passe dans un \xe9tat en attente. Normalement, il reste dans cet \xe9tat pendant tr\xe8s peu de temps et est ensuite envoy\xe9 au processus de destination. Cependant, si ce type de signal est actuellement verrouill\xe9, il pourrait rester ind\xe9finiment en \xe9tat de veille jusqu'\xe0 ce que les signaux de ce type soient d\xe9verrouill\xe9s. Une fois ce type de signal d\xe9verrouill\xe9, il sera envoy\xe9 imm\xe9diatement. Lorsque le signal a \xe9t\xe9 re\xe7u, imm\xe9diatement ou tard, l'action sp\xe9cifi\xe9e pour ce signal est ex\xe9cut\xe9e. Pour certains signaux, tels que ",(0,i.jsx)(n.code,{children:"SIGKILL"})," et ",(0,i.jsx)(n.code,{children:"SIGSTOP"})," , l'action est ",(0,i.jsx)(n.strong,{children:"fixe"})," (le processus est termin\xe9), mais, pour la plupart des signaux, le programme peut choisir de:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ignore"})," le signal"]}),"\n",(0,i.jsxs)(n.li,{children:["sp\xe9cifier une fonction de type ",(0,i.jsx)(n.strong,{children:"handler"})]}),"\n",(0,i.jsxs)(n.li,{children:["accepte ",(0,i.jsx)(n.strong,{children:"l'action par d\xe9faut"})," pour ce type de signal"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"types-de-signaux-standard",children:"Types de signaux standard"}),"\n",(0,i.jsx)(n.p,{children:"Cette section pr\xe9sente les noms des diff\xe9rents types de signaux standard et d\xe9crit le type d'\xe9v\xe9nements qu'ils indiquent."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["Chaque nom de signal est une ",(0,i.jsx)(n.strong,{children:"d\xe9finition de macro"})," qui repr\xe9sente, en fait, un entier positif (le num\xe9ro de ce type de signal)."]})}),"\n",(0,i.jsx)(n.p,{children:"Un programme ne doit jamais faire d'hypoth\xe8ses sur le code num\xe9rique d'un type particulier de signal, mais plut\xf4t s'y r\xe9f\xe9rer toujours par son nom. En effet, un nombre pour un type de signal peut varier d'un syst\xe8me \xe0 l'autre, mais leurs noms sont standard. Pour la liste compl\xe8te des signaux pris en charge par un syst\xe8me, vous pouvez ex\xe9cuter sur la ligne de commande:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ kill -l\n \n     1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL\n     5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE\n     9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2\n    13) SIGPIPE     14) SIGALRM     15) SIGTERM     17) SIGCHLD\n    18) SIGCONT     19) SIGSTOP     20) SIGTSTP     21) SIGTTIN\n    22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ\n    26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO\n    30) SIGPWR      31) SIGSYS      33) SIGRTMIN    34) SIGRTMIN+1\n    35) SIGRTMIN+2  36) SIGRTMIN+3  37) SIGRTMIN+4  38) SIGRTMIN+5\n    39) SIGRTMIN+6  40) SIGRTMIN+7  41) SIGRTMIN+8  42) SIGRTMIN+9\n    43) SIGRTMIN+10 44) SIGRTMIN+11 45) SIGRTMIN+12 46) SIGRTMIN+13\n    47) SIGRTMIN+14 48) SIGRTMIN+15 49) SIGRTMAX-15 50) SIGRTMAX-14\n    51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10\n    55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6\n    59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\n    63) SIGRTMAX-1  64) SIGRTMAX\n"})}),"\n",(0,i.jsx)(n.p,{children:"Les noms de signaux sont d\xe9finis dans l'en-t\xeate signal.h sous Unix. En g\xe9n\xe9ral, les signaux ont des r\xf4les pr\xe9d\xe9finis, mais ils peuvent \xeatre remplac\xe9s par le programmeur. Les plus connus sont les signaux suivants:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"SIGINT"})," - transmis lorsque la combinaison est enfonc\xe9e ",(0,i.jsx)(n.code,{children:"CTRL+C"}),";"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"SIGQUIT"})," - transmis lorsque la combinaison est enfonc\xe9e ",(0,i.jsx)(n.code,{children:"CTRL+\\"}),";"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"SIGSEGV"})," - transmis lors de l'acc\xe8s \xe0 un emplacement de m\xe9moire invalide, etc."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"SIGKILL"})," - ",(0,i.jsx)(n.strong,{children:"ne peut pas"})," \xeatre ignor\xe9 ou remplac\xe9. La transmission de ce signal a pour effet de mettre fin au processus, quel que soit le contexte."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Pour gerer les signaux en Rust on utilise ",(0,i.jsx)(n.a,{href:"https://docs.rs/nix/latest/nix/sys/signal/fn.signal.html",children:"nix::sys::signal::signal"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"tuer-des-processus",children:"Tuer des processus"}),"\n",(0,i.jsx)(n.p,{children:"Si un processus Linux ne r\xe9pond plus ou consomme trop de ressources, vous devrez peut-\xeatre le tuer."}),"\n",(0,i.jsx)(n.p,{children:"La plupart des processus ont leurs propres m\xe9thodes d'arr\xeat. Malheureusement, les processus peuvent mal fonctionner et ne pas se laisser arr\xeater. Si un processus d'arri\xe8re-plan en cours d'ex\xe9cution ne r\xe9pond pas, il devient n\xe9cessaire d'utiliser une commande pour le tuer."}),"\n",(0,i.jsxs)(n.p,{children:["En Rust, on utilise la fonction ",(0,i.jsx)(n.code,{children:"kill"})," qui force le processus fils \xe0 se fermer. Si l'enfant est d\xe9j\xe0 sorti, une erreur InvalidInput est renvoy\xe9e. Cela \xe9quivaut \xe0 envoyer un ",(0,i.jsx)(n.code,{children:"SIGKILL"})," sur les plates-formes Unix."]}),"\n",(0,i.jsx)(n.p,{children:"Exemple:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use std::process::Command;\n \nlet mut command = Command::new("yes");\nif let Ok(mut child) = command.spawn() {\n    child.kill().expect("command wasn\'t running");\n} else {\n    println!("yes command didn\'t start");\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"suggestions",children:"Suggestions"}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.p,{children:"Transformer un String en &[u8] peut \xeatre fait en utilisant"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"s.as_bytes()\n"})})]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:["Transformer un descripteur de fichier en ",(0,i.jsx)(n.code,{children:"File"})," peut \xeatre fait en utilisant"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let mut f = unsafe { fs::File::from_raw_fd(fd) };\n"})})]}),"\n",(0,i.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Compilez ex1. Ex\xe9cutez-le et utilisez la commande shell kill pour lui envoyer des signaux.\nb. Modifiez-le pour qu'\xe0 chaque fois qu'il re\xe7oit un signal, il imprime une lettre diff\xe9rente : a - ",(0,i.jsx)(n.code,{children:"SIGHUP"}),", b - ",(0,i.jsx)(n.code,{children:"SIGINT"}),", n - ",(0,i.jsx)(n.code,{children:"SIQUIT"}),", s - ",(0,i.jsx)(n.code,{children:"SIGTRAP"}),", espace - ",(0,i.jsx)(n.code,{children:"SIGFPE"}),". \xc9crivez un autre programme en Rust qui lui envoie des signaux pour qu'il imprime ",(0,i.jsx)(n.code,{children:"bannanas bannanas"}),". Le deuxi\xe8me programme re\xe7oit le pid de destination \xe0 partir d'un argument de ligne de commande. On utlise la fonction ",(0,i.jsx)(n.a,{href:"https://docs.rs/nix/latest/nix/sys/signal/fn.kill.html",children:"kill"})," pour envoyer un certain signal a un certain processus, en mentionant le PID et le type de signal:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"  kill(Pid::from_raw(/*ici on met le pid*/), Signal::/*type de signal*/); \n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Hint: Pour trouver le pid du processus ex1, utilisez la commande ",(0,i.jsx)(n.strong,{children:"top"})," dans le terminal."]})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Cr\xe9ez un programme qui fait fork et entre dans une boucle infinie (avec un sleep). Son enfant attend quelques secondes puis sort. \xc9crivez un message \xe0 l'\xe9cran lorsque l'enfant sort. Utilisez ",(0,i.jsx)(n.code,{children:"SIGCHLD"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Essayez de stocker une valeur dans un pointeur null. Lors de la r\xe9ception du signal ",(0,i.jsx)(n.code,{children:"SIGSEGV"}),", imprimez l'adresse o\xf9 le d\xe9faut de segmentation s'est produit. Essayez de stocker une valeur dans un pointeur pour une constante. Maintenant, voyez ce qui se passe."]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,t.M)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},2172:(e,n,s)=>{s.d(n,{I:()=>o,M:()=>l});var i=s(1504);const t={},r=i.createContext(t);function l(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);