"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7325],{8185:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"tp/10","title":"TP 10 - Fils d\'Execution","description":"Utilisation des fils d\'execution, Utilisation des mutex et des canaux","source":"@site/versioned_docs/version-2024/tp/10.md","sourceDirName":"tp","slug":"/tp/10","permalink":"/docs/2024/tp/10","draft":false,"unlisted":false,"editUrl":"https://github.com/UPB-FILS-SdE2/upb-fils-sde2.github.io/edit/main/versioned_docs/version-2024/tp/10.md","tags":[],"version":"2024","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"description":"Utilisation des fils d\'execution, Utilisation des mutex et des canaux"},"sidebar":"tutorialSidebar","previous":{"title":"TP 09 - M\xe9moire Virtuelle (Mappage de fichiers)","permalink":"/docs/2024/tp/09"},"next":{"title":"Devoir","permalink":"/docs/2024/category/devoir"}}');var t=r(4848),i=r(8453);const a={sidebar_position:10,description:"Utilisation des fils d'execution, Utilisation des mutex et des canaux"},d="TP 10 - Fils d'Execution",o={},u=[{value:"Resources",id:"resources",level:2},{value:"Fearless Concurrency",id:"fearless-concurrency",level:2},{value:"Utilisation de threads pour ex\xe9cuter du code simultan\xe9ment",id:"utilisation-de-threads-pour-ex\xe9cuter-du-code-simultan\xe9ment",level:3},{value:"spawn",id:"spawn",level:4},{value:"join handle",id:"join-handle",level:3},{value:"Message sending concurrency",id:"message-sending-concurrency",level:3},{value:"Exercises",id:"exercises",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"tp-10---fils-dexecution",children:"TP 10 - Fils d'Execution"})}),"\n",(0,t.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://jimskapt.github.io/rust-book-fr/ch16-00-concurrency.html",children:"Fearless Concurrency"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://doc.rust-lang.org/std/thread/fn.spawn.html",children:"spawn"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://doc.rust-lang.org/book/ch16-03-shared-state.html",children:"Shared-State Concurrency"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"fearless-concurrency",children:"Fearless Concurrency"}),"\n",(0,t.jsx)(n.p,{children:"G\xe9rer la programmation simultan\xe9e de mani\xe8re s\xfbre et efficace est un autre des principaux objectifs de Rust. La programmation simultan\xe9e, o\xf9 diff\xe9rentes parties d'un programme s'ex\xe9cutent ind\xe9pendamment, et la programmation parall\xe8le, o\xf9 diff\xe9rentes parties d'un programme s'ex\xe9cutent en m\xeame temps, deviennent de plus en plus importantes \xe0 mesure que de plus en plus d'ordinateurs tirent parti de leurs multiples processeurs. Historiquement, la programmation dans ces contextes a \xe9t\xe9 difficile et sujette aux erreurs : Rust esp\xe8re changer cela."}),"\n",(0,t.jsx)(n.p,{children:"En tirant parti de la propri\xe9t\xe9 et de la v\xe9rification de type, de nombreuses erreurs de concurrence sont des erreurs de compilation dans Rust plut\xf4t que des erreurs d'ex\xe9cution. Par cons\xe9quent, plut\xf4t que de vous faire passer beaucoup de temps \xe0 essayer de reproduire les circonstances exactes dans lesquelles un bogue de concurrence d'ex\xe9cution se produit, un code incorrect refusera de compiler et pr\xe9sentera une erreur expliquant le probl\xe8me. Par cons\xe9quent, vous pouvez corriger votre code pendant que vous y travaillez plut\xf4t qu'\xe9ventuellement apr\xe8s son envoi en production. Nous avons surnomm\xe9 cet aspect de la concurrence intr\xe9pide de Rust. La concurrence intr\xe9pide vous permet d'\xe9crire du code exempt de bogues subtils et facile \xe0 refactoriser sans introduire de nouveaux bogues."}),"\n",(0,t.jsx)(n.h3,{id:"utilisation-de-threads-pour-ex\xe9cuter-du-code-simultan\xe9ment",children:"Utilisation de threads pour ex\xe9cuter du code simultan\xe9ment"}),"\n",(0,t.jsx)(n.p,{children:"Diviser le calcul de votre programme en plusieurs threads pour ex\xe9cuter plusieurs t\xe2ches en m\xeame temps peut am\xe9liorer les performances, mais cela ajoute \xe9galement de la complexit\xe9. \xc9tant donn\xe9 que les threads peuvent s'ex\xe9cuter simultan\xe9ment, il n'y a aucune garantie inh\xe9rente quant \xe0 l'ordre dans lequel les parties de votre code sur diff\xe9rents threads seront ex\xe9cut\xe9es. Cela peut entra\xeener des probl\xe8mes, tels que :"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Conditions de concurrence"}),", o\xf9 les threads acc\xe8dent aux donn\xe9es ou aux ressources dans un ordre incoh\xe9rent"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deadlocks"}),", o\xf9 deux threads s'attendent, emp\xeachant les deux threads de continuer"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bugs"})," qui ne se produisent que dans certaines situations et sont difficiles \xe0 reproduire et \xe0 corriger de mani\xe8re fiable"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Rust tente d'att\xe9nuer les effets n\xe9gatifs de l'utilisation de threads, mais la programmation dans un contexte multithread n\xe9cessite toujours une r\xe9flexion approfondie et n\xe9cessite une structure de code diff\xe9rente de celle des programmes ex\xe9cut\xe9s dans un seul thread."}),"\n",(0,t.jsx)(n.h4,{id:"spawn",children:"spawn"}),"\n",(0,t.jsxs)(n.p,{children:["Pour cr\xe9er un nouveau thread, nous appelons la fonction ",(0,t.jsx)(n.code,{children:"thread::spawn"})," et lui passons une closure contenant le code que nous voulons ex\xe9cuter dans le nouveau thread."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::thread;\nuse std::time::Duration;\n \nfn main() {\n    thread::spawn(|| {\n        for i in 1..10 {\n            println!("hi number {} from the spawned thread!", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n \n    for i in 1..5 {\n        println!("hi number {} from the main thread!", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.p,{children:"Notez que lorsque le thread principal d'un programme Rust se termine, tous les threads g\xe9n\xe9r\xe9s sont arr\xeat\xe9s, qu'ils aient ou non fini de s'ex\xe9cuter. La sortie de ce programme peut \xeatre un peu diff\xe9rente \xe0 chaque fois, mais elle ressemblera \xe0 ce qui suit :"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"hi number 1 from the main thread!\nhi number 1 from the spawned thread!\nhi number 2 from the main thread!\nhi number 2 from the spawned thread!\nhi number 3 from the main thread!\nhi number 3 from the spawned thread!\nhi number 4 from the main thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:["Les appels \xe0 ",(0,t.jsx)(n.code,{children:"thread::sleep"})," forcent un thread \xe0 arr\xeater son ex\xe9cution pendant une courte dur\xe9e, permettant \xe0 un thread diff\xe9rent de s'ex\xe9cuter. Les threads prendront probablement leur tour, mais ce n'est pas garanti : cela d\xe9pend de la fa\xe7on dont votre syst\xe8me d'exploitation planifie les threads. Dans cette ex\xe9cution, le thread principal s'imprime en premier, m\xeame si l'instruction d'impression du thread g\xe9n\xe9r\xe9 appara\xeet en premier dans le code. Et m\xeame si nous avons dit au thread g\xe9n\xe9r\xe9 d'imprimer jusqu'\xe0 ce que i soit 9, il n'est arriv\xe9 qu'\xe0 5 avant que le thread principal ne s'arr\xeate."]}),"\n",(0,t.jsx)(n.p,{children:"Si vous ex\xe9cutez ce code et ne voyez que la sortie du thread principal, ou ne voyez aucun chevauchement, essayez d'augmenter les nombres dans les plages pour cr\xe9er plus d'opportunit\xe9s pour le syst\xe8me d'exploitation de basculer entre les threads."}),"\n",(0,t.jsx)(n.h3,{id:"join-handle",children:"join handle"}),"\n",(0,t.jsx)(n.p,{children:"Le code precedent arr\xeate non seulement le thread g\xe9n\xe9r\xe9 pr\xe9matur\xe9ment la plupart du temps en raison de la fin du thread principal, mais comme il n'y a aucune garantie sur l'ordre dans lequel les threads s'ex\xe9cutent, nous ne pouvons pas non plus garantir que le thread g\xe9n\xe9r\xe9 sera courir du tout!"}),"\n",(0,t.jsxs)(n.p,{children:["Nous pouvons r\xe9soudre le probl\xe8me du thread g\xe9n\xe9r\xe9 qui ne s'ex\xe9cute pas ou se termine pr\xe9matur\xe9ment en enregistrant la valeur de retour de ",(0,t.jsx)(n.code,{children:"thread :: spawn"})," dans une variable. Le type de retour de ",(0,t.jsx)(n.code,{children:"thread ::spawn"})," est JoinHandle. Un JoinHandle est une valeur poss\xe9d\xe9e qui, lorsque nous appelons la m\xe9thode join dessus, attendra que son thread se termine. Le Lcode suivant montre comment utiliser le JoinHandle du thread que nous avons cr\xe9\xe9 dans le code precedent et appeler join pour s'assurer que le thread g\xe9n\xe9r\xe9 se termine avant les sorties principales :"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::thread;\nuse std::time::Duration;\n \nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!("hi number {} from the spawned thread!", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n \n    for i in 1..5 {\n        println!("hi number {} from the main thread!", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n \n    handle.join().unwrap();\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["L'appel de ",(0,t.jsx)(n.code,{children:"join"})," sur le handle ",(0,t.jsx)(n.strong,{children:"bloque"})," le thread en cours d'ex\xe9cution jusqu'\xe0 ce que le thread repr\xe9sent\xe9 par le handle se termine. Le blocage d'un thread signifie que le thread est emp\xeach\xe9 d'effectuer un travail ou de se fermer. Comme nous avons plac\xe9 l'appel \xe0 join apr\xe8s la boucle for du thread principal, l'ex\xe9cution devrait produire une sortie similaire \xe0 celle-ci :"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"hi number 1 from the main thread!\nhi number 2 from the main thread!\nhi number 1 from the spawned thread!\nhi number 3 from the main thread!\nhi number 2 from the spawned thread!\nhi number 4 from the main thread!\nhi number 3 from the spawned thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\nhi number 6 from the spawned thread!\nhi number 7 from the spawned thread!\nhi number 8 from the spawned thread!\nhi number 9 from the spawned thread!\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Les deux threads continuent d'alterner, mais le thread principal attend \xe0 cause de l'appel \xe0 ",(0,t.jsx)(n.code,{children:"handle.join()"})," et ne se termine pas tant que le thread g\xe9n\xe9r\xe9 n'est pas termin\xe9."]}),"\n",(0,t.jsxs)(n.p,{children:["Mais voyons ce qui se passe quand nous d\xe9pla\xe7ons plut\xf4t ",(0,t.jsx)(n.code,{children:"handle.join()"})," avant la boucle for dans main, comme ceci :"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::thread;\nuse std::time::Duration;\n \nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!("hi number {} from the spawned thread!", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n \n    handle.join().unwrap();\n \n    for i in 1..5 {\n        println!("hi number {} from the main thread!", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Le thread principal attendra que le thread g\xe9n\xe9r\xe9 se termine, puis ex\xe9cutera sa boucle ",(0,t.jsx)(n.code,{children:"for"}),", de sorte que la sortie ne sera plus entrelac\xe9e, comme indiqu\xe9 ici :"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"hi number 1 from the spawned thread!\nhi number 2 from the spawned thread!\nhi number 3 from the spawned thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\nhi number 6 from the spawned thread!\nhi number 7 from the spawned thread!\nhi number 8 from the spawned thread!\nhi number 9 from the spawned thread!\nhi number 1 from the main thread!\nhi number 2 from the main thread!\nhi number 3 from the main thread!\nhi number 4 from the main thread!\n"})}),"\n",(0,t.jsx)(n.h3,{id:"message-sending-concurrency",children:"Message sending concurrency"}),"\n",(0,t.jsxs)(n.p,{children:["Pour r\xe9aliser la simultan\xe9it\xe9 d'envoi de messages, la biblioth\xe8que standard de Rust fournit une impl\xe9mentation de ",(0,t.jsx)(n.strong,{children:"channels"}),". Un canal est un concept de programmation g\xe9n\xe9ral par lequel les donn\xe9es sont envoy\xe9es d'un thread \xe0 un autre."]}),"\n",(0,t.jsx)(n.p,{children:"Vous pouvez imaginer un canal dans la programmation comme \xe9tant comme un canal directionnel d'eau, tel qu'un ruisseau ou une rivi\xe8re. Si vous mettez quelque chose comme un canard en caoutchouc dans une rivi\xe8re, il se d\xe9placera en aval jusqu'au bout de la voie navigable."}),"\n",(0,t.jsxs)(n.p,{children:["Un canal a deux moiti\xe9s : un ",(0,t.jsx)(n.strong,{children:"\xe9metteur"})," et un ",(0,t.jsx)(n.strong,{children:"r\xe9cepteur"}),". La moiti\xe9 de l'\xe9metteur est l'endroit en amont o\xf9 vous mettez les canards en caoutchouc dans la rivi\xe8re, et la moiti\xe9 du r\xe9cepteur est l'endroit o\xf9 le canard en caoutchouc se termine en aval. Une partie de votre code appelle des m\xe9thodes sur l'\xe9metteur avec les donn\xe9es que vous souhaitez envoyer, et une autre partie v\xe9rifie l'extr\xe9mit\xe9 de r\xe9ception pour les messages arrivant. Un canal est dit ",(0,t.jsx)(n.strong,{children:"ferm\xe9"})," si l'\xe9metteur ou la moiti\xe9 r\xe9cepteur est abandonn\xe9."]}),"\n",(0,t.jsx)(n.p,{children:"Example de channel:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"use std::sync::mpsc;\n \nfn main() {\n    let (tx, rx) = mpsc::channel();\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Nous cr\xe9ons un nouveau canal en utilisant la fonction ",(0,t.jsx)(n.code,{children:"mpsc::channel"})," ; mpsc signifie ",(0,t.jsx)(n.em,{children:"multiple producer, single consumer"}),". En bref, la fa\xe7on dont la biblioth\xe8que standard de Rust impl\xe9mente les canaux signifie qu'un canal peut avoir plusieurs extr\xe9mit\xe9s \xe9mettrices qui produisent des valeurs, mais ",(0,t.jsx)(n.strong,{children:"une seule extr\xe9mit\xe9 r\xe9ceptrice"})," qui consomme ces valeurs. Imaginez plusieurs cours d'eau coulant ensemble dans une grande rivi\xe8re : tout ce qui est envoy\xe9 dans l'un des cours d'eau se retrouvera dans une rivi\xe8re \xe0 la fin. Nous allons commencer avec un seul producteur pour le moment, mais nous ajouterons plusieurs producteurs lorsque cet exemple fonctionnera."]}),"\n",(0,t.jsxs)(n.p,{children:["La fonction ",(0,t.jsx)(n.code,{children:"mpsc::channel"})," renvoie un tuple dont le premier \xe9l\xe9ment est l'extr\xe9mit\xe9 \xe9mettrice - ",(0,t.jsx)(n.strong,{children:"l'\xe9metteur"})," - et le second \xe9l\xe9ment est l'extr\xe9mit\xe9 r\xe9ceptrice - ",(0,t.jsx)(n.strong,{children:"le r\xe9cepteur"}),". Les abr\xe9viations ",(0,t.jsx)(n.code,{children:"tx"})," et ",(0,t.jsx)(n.code,{children:"rx"})," sont traditionnellement utilis\xe9es dans de nombreux domaines pour l'\xe9metteur et le r\xe9cepteur respectivement, nous nommons donc nos variables en tant que telles pour indiquer chaque extr\xe9mit\xe9. Nous utilisons une instruction let avec un motif qui d\xe9structure les tuples ; nous discuterons de l'utilisation des motifs dans les instructions let et de la d\xe9structuration au chapitre 18. Pour l'instant, sachez que l'utilisation d'une instruction let de cette mani\xe8re est une approche pratique pour extraire les morceaux du tuple renvoy\xe9 par ",(0,t.jsx)(n.code,{children:"mpsc::channel"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::sync::mpsc;\nuse std::thread;\n \nfn main() {\n    let (tx, rx) = mpsc::channel();\n \n    thread::spawn(move || {\n        let val = String::from("hi");\n        tx.send(val).unwrap();\n    });\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Encore une fois, nous utilisons ",(0,t.jsx)(n.code,{children:"thread::spawn"})," pour cr\xe9er un nouveau thread, puis nous utilisons ",(0,t.jsx)(n.code,{children:"move"})," pour d\xe9placer ",(0,t.jsx)(n.code,{children:"tx"})," dans la fermeture afin que le thread engendr\xe9 poss\xe8de ",(0,t.jsx)(n.code,{children:"tx"}),". Le thread g\xe9n\xe9r\xe9 doit poss\xe9der l'\xe9metteur pour pouvoir envoyer des messages via le canal. L'\xe9metteur a une m\xe9thode d'envoi qui prend la valeur que nous voulons envoyer. La m\xe9thode d'envoi renvoie un type ",(0,t.jsx)(n.code,{children:"Result<T, E>"}),", donc si le r\xe9cepteur a d\xe9j\xe0 \xe9t\xe9 supprim\xe9 et qu'il n'y a nulle part o\xf9 envoyer une valeur, l'op\xe9ration d'envoi renverra une erreur. Dans cet exemple, nous appelons unwrap pour paniquer en cas d'erreur."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::sync::mpsc;\nuse std::thread;\n \nfn main() {\n    let (tx, rx) = mpsc::channel();\n \n    thread::spawn(move || {\n        let val = String::from("hi");\n        tx.send(val).unwrap();\n    });\n \n    let received = rx.recv().unwrap();\n    println!("Got: {}", received);\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Le receveur a deux m\xe9thodes utiles : ",(0,t.jsx)(n.code,{children:"recv"})," et ",(0,t.jsx)(n.code,{children:"try_recv"}),". Nous utilisons recv, abr\xe9viation de receive, qui bloquera l'ex\xe9cution du thread principal et attendra qu'une valeur soit envoy\xe9e sur le canal. Une fois qu'une valeur est envoy\xe9e, ",(0,t.jsx)(n.code,{children:"recv"})," la renverra dans un ",(0,t.jsx)(n.code,{children:"Result<T, E>"}),". Lorsque l'\xe9metteur se ferme, recv renverra une erreur pour signaler qu'aucune autre valeur n'arrivera."]}),"\n",(0,t.jsxs)(n.p,{children:["Nous avons utilis\xe9 ",(0,t.jsx)(n.code,{children:"recv"})," dans cet exemple pour plus de simplicit\xe9 ; nous n'avons pas d'autre travail \xe0 faire pour le thread principal que d'attendre les messages, donc bloquer le thread principal est appropri\xe9."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Vous pouvez d\xe9couvrir comment envoyer plusieurs valeurs au r\xe9cepteur ici: ",(0,t.jsx)(n.a,{href:"https://doc.rust-lang.org/book/ch16-02-message-passing.html#sending-multiple-values-and-seeing-the-receiver-waiting",children:"multiple values"}),"\nAussi utile: ",(0,t.jsx)(n.a,{href:"https://doc.rust-lang.org/book/ch16-02-message-passing.html#creating-multiple-producers-by-cloning-the-transmitter",children:"Creating Multiple Producers by Cloning the Transmitter"})]})}),"\n",(0,t.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Ex\xe9cutez le programme dans ex1. R\xe9pondez aux questions pos\xe9es par le programme."}),"\n",(0,t.jsx)(n.li,{children:"R\xe9solvez les lignes TODO (dans l'ordre) \xe0 partir de ex1."}),"\n",(0,t.jsx)(n.li,{children:"R\xe9solvez les lignes TODO (dans l'ordre) de ex2."}),"\n",(0,t.jsx)(n.li,{children:"R\xe9solvez les lignes TODO (dans l'ordre) de ex3."}),"\n",(0,t.jsx)(n.li,{children:"R\xe9solvez les lignes TODO (dans l'ordre) de ex4."}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>d});var s=r(6540);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);